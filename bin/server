#!/usr/bin/env node

var path = require('path');
var chokidar = require('chokidar');
var domain = require('domain');
var minimist = require('minimist');
var Server = require('../lib/superstatic').Server;
var defaults = require('../lib/defaults');
var ConfigFile = require('../lib/server/settings/file');
var fs = require('fs');
var feedback = require('feedback');
var server;

var argv = minimist(process.argv.slice(2), {
  alias: { p: 'port', h: 'host', q: 'quiet', c: 'config' }
  boolean: 'debug'
  default: {
    port: defaults.PORT,
    host: defaults.HOST,
  }
});

var port = argv.port;
var host = argv.host;
var debug = argv.quiet;
var config = parseOverrideConfig(argv.config) || 'superstatic.json';
var cwd = argv._[0] ? path.resolve(argv._[0]) : defaults.DIRECTORY;
var envJSON = path.join(cwd, '.env.json');

startServer(function(){
  chokidar.watch(server.settings.getConfigFileName())
    .on('change', configFileChanged);
});

function parseOverrideConfig (config) {
  if (!config) return;
  try { var parsed = JSON.parse(config); } catch { return }
  return parsed
}

function startServer (cb) {
  var d = domain.create();
  
  d.run(function () {
    server = createInstance(cwd, host, port);
    server.start(function () {
      feedback.info('Server started on port ' + port.toString() + '\n');
      cb();
    });
  });
  
  d.on('error', serverErrorHandler);
}

function createInstance (cwd, host, port) {
  var localEnv;
  
  try { localEnv = require(envJSON); }
  
  return new Server({
    port: port,
    host: host,
    environment: localEnv,
    cwd: cwd,
    config: config,
    debug: debug,
    _defaults: {
      root: './',
      error_page: path.join(__dirname, '../lib/browser/not_found.html')
    }
  });
}

function serverErrorHandler (err) {
  var msg = err.message;
  
  if (err.message.indexOf('EADDRINUSE') > -1) {
    msg = 'That port is already being used by another program.';
  }
  
  feedback.error(msg);
}

function configFileChanged () {
  feedback.info('Configuration file changed. Restarting...');
  server.stop(startServer);
}
